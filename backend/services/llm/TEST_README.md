# LLM 호출 성능 테스트 스크립트

주간 계획 생성 시 LLM 호출 방식에 따른 성능을 비교하는 테스트 스크립트입니다.

## 📁 파일 구성

### 1. `test_weekly_plan_async.py`
- **방식**: Async 병렬 (현재 구현)
- **설명**: 4개의 LLM 호출을 `asyncio.gather()`로 병렬 실행
- **장점**:
  - 동시 실행으로 대기 시간 최소화
  - 네트워크 I/O 병렬 처리
- **단점**:
  - 코드 복잡도 증가
  - Async/await 구조 필요

### 2. `test_weekly_plan_sync.py`
- **방식**: Sync 순차 실행
- **설명**: 4개의 LLM 호출을 하나씩 순차적으로 실행
- **장점**:
  - 코드가 단순하고 이해하기 쉬움
  - 디버깅 용이
- **단점**:
  - 각 호출이 끝나야 다음 호출 시작
  - 총 대기 시간이 모든 호출 시간의 합

### 3. `test_weekly_plan_single.py`
- **방식**: Single Call (통합 호출)
- **설명**: 4개의 프롬프트를 1개로 합쳐서 1번만 호출
- **장점**:
  - API 호출 횟수 최소화
  - 오버헤드 감소
- **단점**:
  - 프롬프트 길이 증가 → 입력 토큰 비용 증가
  - 하나의 섹션 오류 시 전체 재생성 필요
  - 응답 형식 제어 어려움

### 4. `test_weekly_plan_compare.py`
- **방식**: 종합 비교
- **설명**: 위 3가지 방식을 모두 실행하고 결과 비교
- **출력**: 성능 비교 테이블 및 권장사항

## 🚀 실행 방법

### 개별 테스트 실행

```bash
# Async 병렬 방식 테스트
cd /home/user/projects/ExplainMyBody/backend
python -m services.llm.test_weekly_plan_async

# Sync 순차 방식 테스트
python -m services.llm.test_weekly_plan_sync

# Single Call 방식 테스트
python -m services.llm.test_weekly_plan_single
```

### 종합 비교 테스트 실행

```bash
cd /home/user/projects/ExplainMyBody/backend
python -m services.llm.test_weekly_plan_compare
```

## 📊 출력 정보

각 테스트는 다음 정보를 출력합니다:

1. **타임스탬프**: 시작/종료 시각
2. **단계별 소요 시간**:
   - 프롬프트 생성 시간
   - LLM 호출 시간
   - 후처리 시간
3. **총 소요 시간**
4. **생성된 콘텐츠 길이**

### Async 병렬 방식 예시 출력
```
================================================================================
🔹 Async 병렬 방식 (asyncio.gather)
================================================================================
⏰ 시작 시각: 2026-02-09 14:30:00.123
📝 프롬프트 생성 완료: 0.005초
🤖 LLM 호출 완료: 3.245초
⏰ 종료 시각: 2026-02-09 14:30:03.368

📊 총 소요 시간: 3.250초
   - 프롬프트 생성: 0.005초
   - LLM 호출 (병렬): 3.245초
   - 후처리: 0.000초
```

### 종합 비교 예시 출력
```
📊 성능 비교 결과
┌─────────────────────────┬──────────────┬──────────────┬──────────────┐
│ 방식                    │ 소요 시간    │ 상대 속도    │ 효율성       │
├─────────────────────────┼──────────────┼──────────────┼──────────────┤
│ 1️⃣  Async 병렬 (현재)    │    3.250초  │     1.00x   │ 🏆 최고      │
│ 2️⃣  Sync 순차           │   12.456초  │     3.83x   │              │
│ 3️⃣  Single Call         │    4.123초  │     1.27x   │              │
└─────────────────────────┴──────────────┴──────────────┴──────────────┘

💡 Async 병렬 방식이 Sync 순차 방식보다 73.9% 빠릅니다.
💡 Async 병렬 방식이 Single Call 방식보다 21.2% 빠릅니다.
```

## ⚠️ 주의사항

1. **API 비용**: 각 테스트는 실제 OpenAI API를 호출하므로 비용이 발생합니다.
   - Async/Sync: 각 4번 호출
   - Single Call: 1번 호출 (하지만 프롬프트가 4배 길어짐)

2. **네트워크 의존성**: 결과는 네트워크 상태와 API 서버 부하에 따라 달라질 수 있습니다.

3. **환경 변수**: `.env` 파일에 `OPENAI_API_KEY`가 설정되어 있어야 합니다.

4. **실행 시간**: 전체 비교 테스트는 약 20-30초 정도 소요됩니다.

## 🎯 예상 결과

일반적으로 다음과 같은 순서로 빠를 것으로 예상됩니다:

1. **Async 병렬** (가장 빠름) - 약 3-5초
2. **Single Call** (중간) - 약 4-6초
3. **Sync 순차** (가장 느림) - 약 12-15초

하지만 실제 결과는:
- API 서버의 동시 처리 능력
- 네트워크 레이턴시
- 프롬프트 길이에 따른 처리 시간
등에 따라 달라질 수 있습니다.

## 💡 권장사항

### 현재 구현 (Async 병렬) 유지를 권장하는 경우:
- 실시간 응답이 중요한 경우
- 네트워크 I/O가 병목인 경우
- 각 섹션을 독립적으로 재생성할 필요가 있는 경우

### Single Call 고려 가능한 경우:
- API 호출 횟수를 줄이고 싶은 경우
- 모든 섹션이 항상 함께 생성되는 경우
- 프롬프트 통합으로 인한 출력 품질 저하가 없는 경우

### Sync 순차 방식은 권장하지 않음:
- 단순성을 제외하면 성능상 이점이 없음
- 사용자 대기 시간이 가장 김
